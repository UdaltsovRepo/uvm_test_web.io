<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>uvm_tlm_defines.svh</title><link rel="stylesheet" type="text/css" href="../styles/main.css" /><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.startsWith("?Theme=")){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }document.documentElement.classList.add(t + "Theme")}</script>

<a name="TLM_Implementation_Port_Declaration_Macros"></a><a name="Topic770"></a><div class="CTopic TSection LSystemVerilog first">
 <div class="CTitle">TLM Implementation Port Declaration Macros</div>
 <div class="CBody"><p>The TLM implemenation declaration macros provide a way for components to provide multiple implemenation ports of the same implementation interface. When an implementation port is defined using the built-in set of imps, there must be exactly one implementation of the interface.</p><p>For example, if a component needs to provide a put implemenation then it would have an implementation port defined like:</p><pre class="CText">class mycomp extends uvm_component;<br />  uvm_put_imp#(data_type, mycomp) put_imp;<br />  ...<br />  virtual task put (data_type t);<br />    ...<br />  endtask<br />endclass</pre><p>There are times, however, when you need more than one implementation for for an interface. This set of declarations allow you to easily create a new implemenation class to allow for multiple implementations. Although the new implemenation class is a different class, it can be bound to the same types of exports and ports as the original class. Extending the put example above, lets say that mycomp needs to provide two put implementation ports. In that case, you would do something like:</p><pre class="CText">//Define two new put interfaces which are compatible with uvm_put_ports<br />//and uvm_put_exports.<br /><br />`uvm_put_imp_decl(_1)<br />`uvm_put_imp_decl(_2)<br /><br />class my_put_imp#(type T=int) extends uvm_component;<br />   uvm_put_imp_1#(T) put_imp1;<br />   uvm_put_imp_2#(T) put_imp2;<br />   ...<br />   function void put_1 (input T t);<br />     //puts comming into put_imp1<br />     ...<br />   endfunction<br />   function void put_2(input T t);<br />     //puts comming into put_imp2<br />     ...<br />   endfunction<br />endclass</pre><p>The important thing to note is that each `uvm_&lt;interface&gt;_imp_decl creates a new class of type uvm_&lt;interface&gt;_imp&lt;suffix&gt;, where suffix is the input argument to the macro. For this reason, you will typically want to put these macros in a seperate package to avoid collisions and to allow sharing of the definitions.</p></div>
</div>

<a name="Macros"></a><a name="Topic771"></a><div class="CTopic TGroup LSystemVerilog">
 <div class="CTitle">Macros</div>
</div>

<a name="`uvm_blocking_put_imp_decl"></a><a name="Topic772"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_put_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_put_imp_decl(SFX)</pre><p>Define the class uvm_blocking_put_impSFX for providing blocking put implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_nonblocking_put_imp_decl"></a><a name="Topic773"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_put_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_put_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_put_impSFX for providing non-blocking put implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_put_imp_decl"></a><a name="Topic774"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_put_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_put_imp_decl(SFX)</pre><p>Define the class uvm_put_impSFX for providing both blocking and non-blocking put implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_blocking_get_imp_decl"></a><a name="Topic775"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_get_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_get_imp_decl(SFX)</pre><p>Define the class uvm_blocking_get_impSFX for providing blocking get implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_nonblocking_get_imp_decl"></a><a name="Topic776"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_get_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_get_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_get_impSFX for providing non-blocking get implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_get_imp_decl"></a><a name="Topic777"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_get_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_get_imp_decl(SFX)</pre><p>Define the class uvm_get_impSFX for providing both blocking and non-blocking get implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_blocking_peek_imp_decl"></a><a name="Topic778"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_peek_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_peek_imp_decl(SFX)</pre><p>Define the class uvm_blocking_peek_impSFX for providing blocking peek implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_nonblocking_peek_imp_decl"></a><a name="Topic779"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_peek_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_peek_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_peek_impSFX for providing non-blocking peek implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_peek_imp_decl"></a><a name="Topic780"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_peek_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_peek_imp_decl(SFX)</pre><p>Define the class uvm_peek_impSFX for providing both blocking and non-blocking peek implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_blocking_get_peek_imp_decl"></a><a name="Topic781"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_get_peek_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_get_peek_imp_decl(SFX)</pre><p>Define the class uvm_blocking_get_peek_impSFX for providing the blocking get_peek implemenation.</p></div>
</div>

<a name="`uvm_nonblocking_get_peek_imp_decl"></a><a name="Topic782"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_get_peek_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_get_peek_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_get_peek_impSFX for providing non-blocking get_peek implemenation.</p></div>
</div>

<a name="`uvm_get_peek_imp_decl"></a><a name="Topic783"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_get_peek_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_get_peek_imp_decl(SFX)</pre><p>Define the class uvm_get_peek_impSFX for providing both blocking and non-blocking get_peek implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_blocking_master_imp_decl"></a><a name="Topic784"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_master_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_master_imp_decl(SFX)</pre><p>Define the class uvm_blocking_master_impSFX for providing the blocking master implemenation.</p></div>
</div>

<a name="`uvm_nonblocking_master_imp_decl"></a><a name="Topic785"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_master_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_master_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_master_impSFX for providing the non-blocking master implemenation.</p></div>
</div>

<a name="`uvm_master_imp_decl"></a><a name="Topic786"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_master_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_master_imp_decl(SFX)</pre><p>Define the class uvm_master_impSFX for providing both blocking and non-blocking master implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_blocking_slave_imp_decl"></a><a name="Topic787"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_slave_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_slave_imp_decl(SFX)</pre><p>Define the class uvm_blocking_slave_impSFX for providing the blocking slave implemenation.</p></div>
</div>

<a name="`uvm_nonblocking_slave_imp_decl"></a><a name="Topic788"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_slave_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_slave_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_slave_impSFX for providing the non-blocking slave implemenation.</p></div>
</div>

<a name="`uvm_slave_imp_decl"></a><a name="Topic789"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_slave_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_slave_imp_decl(SFX)</pre><p>Define the class uvm_slave_impSFX for providing both blocking and non-blocking slave implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_blocking_transport_imp_decl"></a><a name="Topic790"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_blocking_transport_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_blocking_transport_imp_decl(SFX)</pre><p>Define the class uvm_blocking_transport_impSFX for providing the blocking transport implemenation.</p></div>
</div>

<a name="`uvm_nonblocking_transport_imp_decl"></a><a name="Topic791"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_nonblocking_transport_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_nonblocking_transport_imp_decl(SFX)</pre><p>Define the class uvm_nonblocking_transport_impSFX for providing the non-blocking transport implemenation.</p></div>
</div>

<a name="`uvm_transport_imp_decl"></a><a name="Topic792"></a><div class="CTopic TMacro LSystemVerilog">
 <div class="CTitle">`uvm_transport_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_transport_imp_decl(SFX)</pre><p>Define the class uvm_transport_impSFX for providing both blocking and non-blocking transport implementations.&nbsp; ~SFX~ is the suffix for the new class type.</p></div>
</div>

<a name="`uvm_analysis_imp_decl"></a><a name="Topic793"></a><div class="CTopic TMacro LSystemVerilog last">
 <div class="CTitle">`uvm_analysis_imp_decl</div>
 <div class="CBody"><pre class="CText">`uvm_analysis_imp_decl(SFX)</pre><p>Define the class uvm_analysis_impSFX for providing an analysis implementation. ~SFX~ is the suffix for the new class type. The analysis implemenation is the write function. The `uvm_analysis_imp_decl allows for a scoreboard (or other analysis component) to support input from many places. For example:</p><pre class="CText">`uvm_analysis_imp_decl(_ingress)<br />`uvm_analysis_imp_decl(_egress)<br /><br />class myscoreboard extends uvm_component;<br />  uvm_analysis_imp_ingress#(mydata, myscoreboard) ingress;<br />  uvm_analysis_imp_egress#(mydata, myscoreboard) egress;<br />  mydata ingress_list[$];<br />  ...<br /><br />  function new(string name, uvm_component parent);<br />    super.new(name,parent);<br />    ingress = new(&quot;ingress&quot;, this);<br />    egress = new(&quot;egress&quot;, this);<br />  endfunction<br /><br />  function void write_ingress(mydata t);<br />    ingress_list.push_back(t);<br />  endfunction<br /><br />  function void write_egress(mydata t);<br />    find_match_in_ingress_list(t);<br />  endfunction<br /><br />  function void find_match_in_ingress_list(mydata t);<br />    //implement scoreboarding for this particular dut<br />    ...<br />  endfunction<br />endclass</pre></div>
</div>

</body></html>