<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>tlm1.txt</title><link rel="stylesheet" type="text/css" href="../styles/main.css" /><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.startsWith("?Theme=")){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }document.documentElement.classList.add(t + "Theme")}</script>

<a name="TLM1_Interfaces,Ports,Exports_and_Transport_Interfaces"></a><a name="Topic1490"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">TLM1 Interfaces, Ports, Exports and Transport Interfaces</div>
 <div class="CBody"><p>Each TLM1 interface is either blocking, non-blocking, or a combination of these two.</p><table class="CDefinitionList"><tr><td class="CDLEntry">blocking</td><td class="CDLDefinition"><p>A blocking interface conveys transactions in blocking fashion; its methods do not return until the transaction has been successfully sent or retrieved. Because delivery may consume time to complete, the methods in such an interface are declared as tasks.</p></td></tr><tr><td class="CDLEntry">non-blocking</td><td class="CDLDefinition"><p>A non-blocking interface attempts to convey a transaction without consuming simulation time. Its methods are declared as functions.&nbsp; Because delivery may fail (e.g. the target component is busy and can not accept the request), the methods may return with failed status.</p></td></tr><tr><td class="CDLEntry">combination</td><td class="CDLDefinition"><p>A combination interface contains both the blocking and non-blocking variants.&nbsp; In SystemC, combination interfaces are defined through multiple inheritance.&nbsp; Because SystemVerilog does not support multiple inheritance, the UVM emulates hierarchical interfaces via a common base class and interface mask.</p></td></tr></table><p>Like their SystemC counterparts, the UVM's TLM port and export implementations allow connections between ports whose interfaces are not an exact match.&nbsp; For example, an ~uvm_blocking_get_port~ can be connected to any port, export or imp port that provides ~at the least~ an implementation of the blocking_get interface, which includes the ~uvm_get_*~ ports and exports, ~uvm_blocking_get_peek_*~ ports and exports, and ~uvm_get_peek_*~ ports and exports.</p><p>The sections below provide and overview of the unidirectional and bidirectional TLM interfaces, ports, and exports.</p></div>
</div>

<a name="Unidirectional_Interfaces_Ports"></a><a name="Topic1491"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">Unidirectional Interfaces &amp; Ports</div>
 <div class="CBody"><p>The unidirectional TLM interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the ~put~, ~get~ and ~peek~ interfaces, plus a non-blocking ~analysis~ interface.</p></div>
</div>

<a name="Put"></a><a name="Topic1492"></a><div class="CTopic TInformation LTextFile">
 <div class="CTitle">Put</div>
 <div class="CBody"><p>The ~put~ interfaces are used to send, or ~put~, transactions to other components.&nbsp; Successful completion of a put guarantees its delivery, not execution.</p><div class="CImage"><a href="../images/uvm_ref_tlm_put_ifs.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_put_ifs.gif" loading="lazy" class="KnownDimensions" width="261" height="172" style="max-width: 261px" alt="uvm_ref_tlm_put_ifs" /></a></div></div>
</div>

<a name="Get_and_Peek"></a><a name="Topic1493"></a><div class="CTopic TInformation LTextFile">
 <div class="CTitle">Get and Peek</div>
 <div class="CBody"><p>The ~get~ interfaces are used to retrieve transactions from other components.&nbsp; The ~peek~ interfaces are used for the same purpose, except the retrieved transaction is not consumed; successive calls to ~peek~ will return the same object. Combined ~get_peek~ interfaces are also defined.</p><div class="CImage"><a href="../images/uvm_ref_tlm_get_peek_ifs.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_get_peek_ifs.gif" loading="lazy" class="KnownDimensions" width="527" height="470" style="max-width: 527px" alt="uvm_ref_tlm_get_peek_ifs" /></a></div></div>
</div>

<a name="Ports,Exports,and_Imps"></a><a name="Topic1494"></a><div class="CTopic TInformation LTextFile">
 <div class="CTitle">Ports, Exports, and Imps</div>
 <div class="CBody"><p>The UVM provides unidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces.</p><table class="CDefinitionList"><tr><td class="CDLEntry">Ports</td><td class="CDLDefinition"><p>instantiated in components that ~require~, or ~use~, the associate interface to initiate transaction requests.</p></td></tr><tr><td class="CDLEntry">Exports</td><td class="CDLDefinition"><p>instantiated by components that ~forward~ an implementation of the methods defined in the associated interface. The implementation is typically provided by an ~imp~ port in a child component.</p></td></tr><tr><td class="CDLEntry">Imps</td><td class="CDLDefinition"><p>instantiated by components that ~provide~ or ~implement~ an implementation of the methods defined in the associated interface.</p></td></tr></table><div class="CImage"><a href="../images/uvm_ref_tlm_uni_ports.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_uni_ports.gif" loading="lazy" class="KnownDimensions" width="397" height="227" style="max-width: 397px" alt="uvm_ref_tlm_uni_ports" /></a></div><p>A summary of port, export, and imp declarations are</p><pre class="CText">class uvm_*_export #(type T=int)<br />  extends uvm_port_base #(tlm_if_base #(T,T));<br /><br />class uvm_*_port #(type T=int)<br />  extends uvm_port_base #(tlm_if_base #(T,T));<br /><br />class uvm_*_imp #(type T=int)<br />  extends uvm_port_base #(tlm_if_base #(T,T));</pre><p>where the asterisk can be any of</p><pre class="CText">blocking_put<br />nonblocking_put<br />put<br /><br />blocking_get<br />nonblocking_get<br />get<br /><br />blocking_peek<br />nonblocking_peek<br />peek<br /><br />blocking_get_peek<br />nonblocking_get_peek<br />get_peek<br /><br />analysis</pre></div>
</div>

<a name="Bidirectional_Interfaces_Ports"></a><a name="Topic1495"></a><div class="CTopic TGroup LTextFile">
 <div class="CTitle">Bidirectional Interfaces &amp; Ports</div>
 <div class="CBody"><p>The bidirectional interfaces consist of blocking, non-blocking, and combined blocking and non-blocking variants of the ~transport~, ~master~, and ~slave~ interfaces.</p><p>Bidirectional interfaces involve both a transaction request and response.</p></div>
</div>

<a name="Transport"></a><a name="Topic1496"></a><div class="CTopic TInformation LTextFile">
 <div class="CTitle">Transport</div>
 <div class="CBody"><p>The ~transport~ interface sends a request transaction and returns a response transaction in a single task call, thereby enforcing an in-order execution semantic. The request and response transactions can be different types.</p><div class="CImage"><a href="../images/uvm_ref_tlm_transport_ifs.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_transport_ifs.gif" loading="lazy" class="KnownDimensions" width="322" height="160" style="max-width: 322px" alt="uvm_ref_tlm_transport_ifs" /></a></div></div>
</div>

<a name="Master_and_Slave"></a><a name="Topic1497"></a><div class="CTopic TInformation LTextFile">
 <div class="CTitle">Master and Slave</div>
 <div class="CBody"><p>The primitive, unidirectional ~put~, ~get~, and ~peek~ interfaces are combined to form bidirectional master and slave interfaces.&nbsp; The master puts requests and gets or peeks responses. The slave gets or peeks requests and puts responses. Because the put and the get come from different function interface methods, the requests and responses are not coupled as they are with the ~transport~ interface.</p><div class="CImage"><a href="../images/uvm_ref_tlm_master_slave_ifs.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_master_slave_ifs.gif" loading="lazy" class="KnownDimensions" width="611" height="451" style="max-width: 611px" alt="uvm_ref_tlm_master_slave_ifs" /></a></div></div>
</div>

<a name="Ports,Exports,and_Imps(2)"></a><a name="Topic1498"></a><div class="CTopic TInformation LTextFile">
 <div class="CTitle">Ports, Exports, and Imps</div>
 <div class="CBody"><p>The UVM provides bidirectional ports, exports, and implementation ports for connecting your components via the TLM interfaces.</p><table class="CDefinitionList"><tr><td class="CDLEntry">Ports</td><td class="CDLDefinition"><p>instantiated in components that ~require~, or ~use~, the associate interface to initiate transaction requests.</p></td></tr><tr><td class="CDLEntry">Exports</td><td class="CDLDefinition"><p>instantiated by components that ~forward~ an implementation of the methods defined in the associated interface. The implementation is typically provided by an ~imp~ port in a child component.</p></td></tr><tr><td class="CDLEntry">Imps</td><td class="CDLDefinition"><p>instantiated by components that ~provide~ or ~implement~ an implementation of the methods defined in the associated interface.</p></td></tr></table><div class="CImage"><a href="../images/uvm_ref_tlm_bidir_ports.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_bidir_ports.gif" loading="lazy" class="KnownDimensions" width="409" height="227" style="max-width: 409px" alt="uvm_ref_tlm_bidir_ports" /></a></div><p>A summary of port, export, and imp declarations are</p><pre class="CText">class uvm_*_port #(type REQ=int, RSP=int)<br />  extends uvm_port_base #(tlm_if_base #(REQ, RSP));<br /><br />class uvm_*_export #(type REQ=int, RSP=int)<br />  extends uvm_port_base #(tlm_if_base #(REQ, RSP));<br /><br />class uvm_*_imp #(type REQ=int, RSP=int)<br />  extends uvm_port_base #(tlm_if_base #(REQ, RSP));</pre><p>where the asterisk can be any of</p><pre class="CText">transport<br />blocking_transport<br />nonblocking_transport<br /><br />blocking_master<br />nonblocking_master<br />master<br /><br />blocking_slave<br />nonblocking_slave<br />slave</pre></div>
</div>

<a name="Usage"></a><a name="Topic1499"></a><div class="CTopic TGroup LTextFile last">
 <div class="CTitle">Usage</div>
 <div class="CBody"><p>This example illustrates basic TLM connectivity using the blocking put inteface.</p><div class="CImage"><a href="../images/uvm_ref_tlm_hierarchy.gif" target="_blank" class="ZoomLink"><img src="../images/uvm_ref_tlm_hierarchy.gif" loading="lazy" class="KnownDimensions" width="486" height="236" style="max-width: 486px" alt="uvm_ref_tlm_hierarchy" /></a></div><table class="CDefinitionList"><tr><td class="CDLEntry">port-to-port</td><td class="CDLDefinition"><p>leaf1's ~out~ port is connected to its parent's (comp1) ~out~ port</p></td></tr><tr><td class="CDLEntry">port-to-export</td><td class="CDLDefinition"><p>comp1's ~out~ port is connected to comp2's ~in~ export</p></td></tr><tr><td class="CDLEntry">export-to-export</td><td class="CDLDefinition"><p>comp2's ~in~ export is connected to its child's (subcomp2) ~in~ export</p></td></tr><tr><td class="CDLEntry">export-to-imp</td><td class="CDLDefinition"><p>subcomp2's ~in~ export is connected leaf2's ~in~ imp port.</p></td></tr><tr><td class="CDLEntry">imp-to-implementation</td><td class="CDLDefinition"><p>leaf2's ~in~ imp port is connected to its implementation, leaf2</p></td></tr></table><p>Hierarchical port connections are resolved and optimized just before the &lt;uvm_component::end_of_elaboration&gt; phase. After optimization, calling any port's interface method (e.g. leaf1.out.put(trans)) incurs a single hop to get to the implementation (e.g. leaf2's put task), no matter how far up and down the hierarchy the implementation resides.</p><pre class="CText">`include &quot;uvm_pkg.sv&quot;<br />import uvm_pkg::*;<br /><br />class trans extends uvm_transaction;<br />  rand int addr;<br />  rand int data;<br />  rand bit write;<br />endclass<br /><br />class leaf1 extends uvm_component;<br /><br />  `uvm_component_utils(leaf1)<br /><br />  uvm_blocking_put_port #(trans) out;<br /><br />  function new(string name, uvm_component parent=null);<br />    super.new(name,parent);<br />    out = new(&quot;out&quot;,this);<br />  endfunction<br /><br />  virtual task run();<br />    trans t;<br />    t = new;<br />    t.randomize();<br />    out.put(t);<br />  endtask<br /><br />endclass<br /><br /><br />class comp1 extends uvm_component;<br /><br />  `uvm_component_utils(comp1)<br /><br />  uvm_blocking_put_port #(trans) out;<br /><br />  leaf1 leaf;<br /><br />  function new(string name, uvm_component parent=null);<br />    super.new(name,parent);<br />  endfunction<br /><br />  virtual function void build();<br />    out = new(&quot;out&quot;,this);<br />    leaf = new(&quot;leaf1&quot;,this);<br />  endfunction<br /><br />  // connect port to port<br />  virtual function void connect();<br />    leaf.out.connect(out);<br />  endfunction<br /><br />endclass<br /><br /><br />class leaf2 extends uvm_component;<br /><br />  `uvm_component_utils(leaf2)<br /><br />  uvm_blocking_put_imp #(trans,leaf2) in;<br /><br />  function new(string name, uvm_component parent=null);<br />    super.new(name,parent);<br />    // connect imp to implementation (this)<br />    in = new(&quot;in&quot;,this);<br />  endfunction<br /><br />  virtual task put(trans t);<br />    $display(&quot;Got trans: addr=%0d, data=%0d, write=%0d&quot;,<br />        t.addr, t.data, t.write);<br />  endtask<br /><br />endclass<br /><br /><br />class subcomp2 extends uvm_component;<br /><br />  `uvm_component_utils(subcomp2)<br /><br />  uvm_blocking_put_export #(trans) in;<br /><br />  leaf2 leaf;<br /><br />  function new(string name, uvm_component parent=null);<br />    super.new(name,parent);<br />  endfunction<br /><br />  virtual function void build();<br />    in = new(&quot;in&quot;,this);<br />    leaf = new(&quot;leaf2&quot;,this);<br />  endfunction<br /><br />  // connect export to imp<br />  virtual function void connect();<br />    in.connect(leaf.in);<br />  endfunction<br /><br />endclass<br /><br /><br />class comp2 extends uvm_component;<br /><br />  `uvm_component_utils(comp2)<br /><br />  uvm_blocking_put_export #(trans) in;<br /><br />  subcomp2 subcomp;<br /><br />  function new(string name, uvm_component parent=null);<br />    super.new(name,parent);<br />  endfunction<br /><br />  virtual function void build();<br />    in = new(&quot;in&quot;,this);<br />    subcomp = new(&quot;subcomp2&quot;,this);<br />  endfunction<br /><br />  // connect export to export<br />  virtual function void connect();<br />    in.connect(subcomp.in);<br />  endfunction<br /><br />endclass<br /><br /><br />class env extends uvm_component;<br /><br />  `uvm_component_utils(comp1)<br /><br />  comp1 comp1_i;<br />  comp2 comp2_i;<br /><br />  function new(string name, uvm_component parent=null);<br />    super.new(name,parent);<br />  endfunction<br /><br />  virtual function void build();<br />    comp1_i = new(&quot;comp1&quot;,this);<br />    comp2_i = new(&quot;comp2&quot;,this);<br />  endfunction<br /><br />  // connect port to export<br />  virtual function void connect();<br />    comp1_i.out.connect(comp2_i.in);<br />  endfunction<br /><br />endclass<br /><br /><br />module top;<br />  env e = new(&quot;env&quot;);<br />  initial run_test();<br />  initial #10 uvm_top.stop_request();<br />endmodule</pre></div>
</div>

</body></html>