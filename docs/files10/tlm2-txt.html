<!DOCTYPE html>

<html class="NDPage NDContentPage"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>tlm2.txt</title><link rel="stylesheet" type="text/css" href="../styles/main.css" /><script type="text/javascript" src="../styles/main.js"></script><script type="text/javascript">NDLoader.LoadJS("Content", "../styles/");</script></head>

<!-- Generated by Natural Docs, version 2.3 -->

<!-- saved from url=(0016)http://localhost -->

<body onload="NDLoader.OnLoad('Content');">

<script type="text/javascript">var q = window.location.search;if (q.startsWith("?Theme=")){var t = q.slice(7);var e = t.indexOf(";");if (e != -1){  t = t.slice(0, e);  }document.documentElement.classList.add(t + "Theme")}</script>

<a name="TLM2_Interfaces,Ports,Exports_and_Transport_Interfaces_Subset"></a><a name="Topic1292"></a><div class="CTopic TSection LTextFile first">
 <div class="CTitle">TLM2 Interfaces, Ports, Exports and Transport Interfaces Subset</div>
 <div class="CBody"><p>Sockets group together all the necessary core interfaces for transportation and binding, allowing more generic usage models than just TLM core interfaces.</p><p>A socket is like a port or export; in fact it is derived from the same base class as ports and export, namely <a href="../index.html#File2:uvm_port_base.svh:uvm_port_base_" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2074);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >uvm_port_base #(IF)</a>.&nbsp; However, unlike a port or export a socket provides both a forward and backward path. Thus you can enable asynchronous (pipelined) bi-directional communication by connecting sockets together. To enable this, a socket contains both a port and an export.&nbsp; Components that initiate transactions are called initiators, and components that receive transactions sent by an initiator are called targets. Initiators have initiator sockets and targets have target sockets. Initiator sockets can connect to target sockets. You cannot connect initiator sockets to other initiator sockets and you cannot connect target sockets to target sockets.</p><p>The UVM TLM2 subset provides the following two transport interfaces:</p><table class="CDefinitionList"><tr><td class="CDLEntry">Blocking (b_transport)</td><td class="CDLDefinition"><p>completes the entire transaction within a single method call</p></td></tr><tr><td class="CDLEntry">Non-blocking (nb_transport)</td><td class="CDLDefinition"><p>describes the progress of a transaction using multiple nb_transport() method calls going back-and-forth between initiator and target</p></td></tr></table><p>In general,any component might modify a transaction object during its lifetime (subject to the rules of the protocol). Significant timing points during the lifetime of a transaction (for example: start-ofresponse- phase) are indicated by calling nb_transport() in either forward or backward direction, the specific timing point being given by the phase argument.&nbsp; Protocol-specific rules for reading or writing the attributes of a transaction can be expressed relative to the phase. The phase can be used for flow control, and for that reason might have a different value at each hop taken by a transaction; the phase is not an attribute of the transaction object.</p><p>A call to nb_transport() always represents a phase transition.&nbsp; However, the return from nb_transport() might or might not do so, the choice being indicated by the value returned from the function (<a href="../index.html#File10:uvm_tlm2_ifs.svh:UVM_TLM_ACCEPTED" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1255);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >UVM_TLM_ACCEPTED</a> versus <a href="../index.html#File10:uvm_tlm2_ifs.svh:UVM_TLM_UPDATED" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1256);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >UVM_TLM_UPDATED</a>).&nbsp; Generally, you indicate the completion of a transaction over a particular hop using the value of the phase argument. As a shortcut, a target might indicate the completion of the transaction by returning a special value of <a href="../index.html#File10:uvm_tlm2_ifs.svh:UVM_TLM_COMPLETED" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,1257);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >UVM_TLM_COMPLETED</a>. However, this is an option, not a necessity.</p><p>The transaction object itself does not contain any timing information by design. Or even events and status information concerning the API. You can pass the delays as arguments to b_transport()/ nb_transport() and push the actual realization of any delay in the simulator kernel downstream and defer (for simulation speed).</p><div class="CHeading">Use Models</div><p>Since sockets are derived from <a href="../index.html#File2:uvm_port_base.svh:uvm_port_base_" target="_top" onmouseover="NDContentPage.OnLinkMouseOver(event,2074);" onmouseout="NDContentPage.OnLinkMouseOut(event);" >uvm_port_base #(IF)</a> they are created and connected in the same way as port, and exports. Create them in the build phase and connect them in the connect phase by calling connect().&nbsp; Initiator and target termination sockets are on the ends of any connection.&nbsp; There can be an arbitrary number of passthrough sockets in the path between initator and target.&nbsp; Some socket types must be bound to imps&nbsp; implementations of the transport tasks and functions. Blocking terminator sockets must be bound to an implementation of b_transport(), for example. Nonblocking initiator sockets must be bound to an implementation of nb_transport_bw() and nonblocking target sockets must be bound to an implementation of nb_transport_fw(). Typically, the task or function is implemented in the component in which the socket is instantiated and the component type and instance are provided to complete the binding.</p><p>Consider for example a consumer component with a blocking target socket.</p><div class="CHeading">Example</div><pre class="CText">class consumer extends uvm_component;<br />   tlm2_b_target_socket #(consumer, trans) target_socket;<br />   function new(string name, uvm_component parent);<br />     super.new(name, parent);<br />   endfunction<br />   function void build();<br />     target_socket = new(&quot;target_socket&quot;, this, this);<br />   endfunction<br />   task b_transport(trans t, uvm_tlm_time delay);<br />     #5;<br />     uvm_report_info(&quot;consumer&quot;, t.convert2string());<br />   endtask<br />endclass</pre><p>The interface task b_transport() is implemented in the consumer component.&nbsp; The consumer component type is used in the declaration of the target socket.&nbsp; This informs the socket object the type of the object that contains the interface task, in this case b_transport(). When the socket is instantiated &quot;this&quot; is passed in twice, once as the parent just like any other component instantiation and again to identify the object that holds the implementation of b_transport(). Finally, in order to complete the binding, an implementation of b_transport() must be present in the consumer component.&nbsp; Any component that has either a blocking termination socket, a nonblocking initiator socket, or a nonblocking termination socket must provide implementations of the relevant components. This includes initiator and target components as well as interconnect components that have these kinds of sockets. Components with passthrough sockets do not need to provide implementations of any sort. Of course, they must ultimately be connected to sockets that do that the necessary implementations.</p><p>In summary: Call to b_transport() - start-of-life of transaction Return from b_transport() - end-of-life of transaction Phase argument to nb_transport() - timing point within lifetime of transaction Return value of nb_transport() - whether return path is being used (also shortcut to final phase) Response status within transaction object - protocol-specific status, success/failure of transaction</p><p>On top of this, TLM-2.0 defines a generic payload and base protocol to enhance interoperability for models with a memory-mapped bus interface.</p><p>It is possible to use the interfaces described above with user-defined transaction types and protocols for the sake of interoperability.&nbsp; However, TLM-2.0 strongly recommends either using the base protocol off-the-shelf or creating models of specific protocols on top of the base protocol.</p><p>The UVM 1.1 standard only defines and supports this TLM2 style interface for SystemVerilog to SystemVerlog communication. Mixed languanged TLM communication is saved for future extension.</p></div>
</div>

</body></html>