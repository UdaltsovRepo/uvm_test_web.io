NDContentPage.OnToolTipsLoaded({347:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"NDClassPrototype\" id=\"NDClassPrototype347\"><div class=\"CPEntry TClass Current\"><div class=\"CPName\">uvm_cmdline_processor</div></div></div><div class=\"TTSummary\">This class provides an interface to the command line arguments that were provided for the given simulation.&nbsp; The class is intended to be used as a singleton, but that isn\'t required.&nbsp; The generation of the data structures which hold the command line argument information happens during construction of the class object.&nbsp; A global variable called ~uvm_cmdline_proc~ is created at initialization time and may be used to access command line information.</div></div>",377:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">The UVM register layer defines several base classes that, when properly extended, abstract the read/write operations to registers and memories in a design-under-verification.</div></div>",724:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">Each of UVM\'s policy classes perform a specific task for &lt;uvm_object&gt;-based objects: printing, comparing, recording, packing, and unpacking. They are implemented separately from ~uvm_object~ so that users can plug in different ways to print, compare, etc. without modifying the object class being operated on. The user can simply apply a different printer or compare &quot;policy&quot; to change how an object is printed or compared.</div></div>",943:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">Sequences encapsulate user-defined procedures that generate multiple &lt;uvm_sequence_item&gt;-based transactions. Such sequences can be reused, extended, randomized, and combined sequentially and hierarchically in interesting ways to produce realistic stimulus to your DUT.</div></div>",989:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">The sequencer serves as an arbiter for controlling transaction flow from multiple stimulus generators. More specifically, the sequencer controls the flow of &lt;uvm_sequence_item&gt;-based transactions generated by one or more &lt;uvm_sequence #(REQ,RSP)&gt;-based sequences.</div></div>",1218:"<div class=\"NDToolTip TGroup LTextFile\"><div class=\"TTSummary\">Components form the foundation of the UVM. They encapsulate behavior of drivers, scoreboards, and other objects in a testbench.&nbsp; The UVM library provides a set of predefined component types, all derived directly or indirectly from uvm_component.</div></div>",1247:"<div class=\"NDToolTip TGroup LSystemVerilog\"><div class=\"TTSummary\">Global macro\'s &amp; enums</div></div>",1500:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">The container classes are type parameterized datastructures. The uvm_queue #(T) class implements a queue datastructure similar to the SystemVerilog queue construct. And the uvm_pool #(KEY,T) class implements a pool datastructure similar to the SystemVerilog associative array. The class based datastructures allow the objects to be shared by reference; for example, a copy of a uvm_pool #(KEY,T) object will copy just the class handle instead of the entire associative array.</div></div>",1533:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">The UVM provides event and barrier synchronization classes for managing concurrent processes.</div></div>",1561:"<div class=\"NDToolTip TClass LSystemVerilog\"><div class=\"NDClassPrototype\" id=\"NDClassPrototype1561\"><div class=\"CPEntry TClass Current\"><div class=\"CPModifiers\"><span class=\"SHKeyword\">virtual</span></div><div class=\"CPName\">uvm_component</div></div></div><div class=\"TTSummary\">The uvm_component class is the root base class for UVM components. In addition to the features inherited from uvm_object and uvm_report_object, uvm_component provides the following interfaces:</div></div>",1731:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">The configuration and resources classes provide access to a centralized database where type specific information can be stored and recieved.&nbsp; The uvm_resource_db is the low level resource database which users can write to or read from. The uvm_config_db is layered on top of the resoure database and provides a typed intereface for configuration setting that is consistent with the uvm_component::Configuration Interface.</div></div>",1877:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">UVM implements an automated mechanism for phasing the execution of the various components in a testbench.</div></div>",1879:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">As the name implies, the uvm_factory is used to manufacture (create) UVM objects and components. Only one instance of the factory is present in a given simulation.</div></div>",1910:"<div class=\"NDToolTip TGroup LTextFile\"><div class=\"TTSummary\">The reporting classes provide a facility for issuing reports with consistent formatting. Users can configure what actions to take and what files to send output to based on report severity, ID, or both severity and ID. Users can also filter messages based on their verbosity settings.</div></div>",2167:"<div class=\"NDToolTip TSection LTextFile\"><div class=\"TTSummary\">The UVM library defines a set of base classes and utilities that facilitate the design of modular, scalable, reusable verification environments.</div></div>"});